# minishell
## 第一章
はじめに
シェルの存在は、ITの存在そのものに繋がっている。
当時、1/0のスイッチの並びでコンピュータと通信するのは、非常に煩わしいというのが開発者の共通認識だった。
そこで、人間の言語に近い、対話的な命令文でコンピュータと通信するソフトを作ろうということになったのである。
Minishellのおかげで、タイムスリップして、Windowsが存在しなかった時代に人々が直面した問題に立ち戻ることができるのだ。

## 第二章
省略
## 第三章
Mandatory part
- Program name: minishell
- Turn in files: Makefile, *.h, *.c
- Makefile: NAME, all, clean, fclean, re
- Arguments:
- External functs.
  - readline
  - rl_clear_history
  - rl_on_new_line,
  - rl_replace_line
  - rl_redisplay
  - add_history
  - printf
  - malloc
  - free
  - write
  - access
  - open
  - read
  - close
  - fork
  - wait
  - waitpid
  - wait3
  - wait4
  - signal
  - sigaction
  - sigemptyset
  - sigaddset
  - kill
  - exit
  - getcwd
  - chdir
  - stat
  - lstat
  - fstat
  - unlink
  - execve
  - dup
  - dup2
  - pipe
  - opendir
  - readdir
  - closedir
  - strerror
  - perror
  - isatty
  - ttyname
  - ttyslot
  - ioctl
  - getenv
  - tcsetattr
  - tcgetattr
  - tgetent
  - tgetflag
  - tgetnum
  - tgetstr
  - tgoto
  - tputs
- Libft authorized: Yes
- Description: Write a shell

あなたのシェルは
- 新しいコマンドを待つときにプロンプトを表示する。
- 作業履歴を持つ。
- 正しい実行ファイルを検索して起動する（PATH変数に基づくか、相対パスまたは絶対パスを使用する）。
- 複数のグローバル変数を使用しない。考えてみてください。その目的を説明する必要があります。
- 閉じない引用符や、対象が必要としない特殊文字(例えば、" \"(バックスラッシュ)や"；"(セミコロン))を解釈しない。
- ハンドル ' (シングルクォート) error
- ハンドル " (二重引用符) は、$ (ドル記号) を除く引用符で囲まれた文字列のメタキャラクタをシェルが解釈しないようにします。
- リダイレクションの実装。
  - `<`は入力をリダイレクトします。
  - `>` は出力をリダイレクトします。
  - `<<` にはデリミタを与え、そのデリミタを含む行が現れるまで入力を読み込むようにします。しかし、ヒストリを更新する必要はありません!
  - 追記モードでは `>>` が出力をリダイレクトする必要があります。
- パイプ (| 文字) を実装します。パイプラインの各コマンドの出力は、パイプを介して次のコマンドの入力に接続されます。
- 環境変数($の後に文字列が続く)を処理し、その値に展開します。
- ハンドル$?は最も最近実行されたフォアグラウンドパイプラインの終了ステータスに展開されるはずです。
- ctrl-C、ctrl-D、ctrl-\は、bashと同じように扱えます。
- 対話型モードでは
  - ctrl-Cは新しいプロンプトを新しい行に表示します。
  - ctrl-D はシェルを終了します。
  - ctrl-\ は何もしません。
- シェルは以下のビルトインを実装する必要があります。
  - echo と -n オプション
  - 相対パスまたは絶対パスのみを指定したcd
  - pwd (オプションなし)
  - export (オプションなし)
  - unset (オプションなし)
  - env (オプションなし)
  - exit (オプションなし)
readline()関数はメモリリークを引き起こす可能性があります。あなたはそれを修正する必要はありません。しかし、それはあなた自身のコード、そう、あなたが書いたコードがメモリリークを起こす可能性があるということではありません。
```
お題の説明に限定したほうがいい。聞かれていないことは要求されていない。
要件に疑問がある場合は、bashを参考にすること。
```
## 第四章
ボーナスパート
あなたのプログラムは実装しなければならない。
- 優先順位を表す括弧付きの && と || を実装してください。
- ワイルドカード * は、現在の作業ディレクトリに対して機能する必要があります。
```
ボーナスパートは、必須パートがパーフェクトである場合にのみ評価されます。パーフェクトとは、必須パートが統合的に行われ、誤動作なく動作することを意味します。
もし、必須項目をすべてクリアしていない場合、ボーナス部分はまったく評価されません。
```

## 第五章
課題の提出と相互評価
通常通り、Git リポジトリに課題を提出してください。リポジトリ内の作品だけが、ディフェンス時に評価されます。
ファイル名に間違いがないか、遠慮なく再確認してください。
